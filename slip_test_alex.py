from pydrake.all import MathematicalProgram, Solve, PiecewisePolynomial
from pydrake.autodiffutils import AutoDiffXd
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicHermiteSpline

from aslip import ASLIP


class OfflinePlanner:
    def __init__(self):
        """
        Offline center of mass (CoM) trajectory optimizer
        for jumping biped. Uses actuated SLIP (aSLIP) model
        """
        # Model
        self.aslip = ASLIP()

        # State parameters
        self.x_0 = self.aslip.x_0  # initial state

        # Collocation parameters
        self.N = 5  # number of knot points

    def find_com_trajectory(
        self, final_state: np.array, t_f: float, jumping_distance: np.array
    ) -> list:
        """
        Finds the CoM trajectory

        Arguments:
            final_state - (np.array) final configuration
            t_f - (float) final time
            jumping distance - (np.array) distance in x & y the CoM should jump [m]

        Returns:
            [x_traj, u_traj] - (list) trajectory generated by optimizer
        """
        # Create the mathematical program
        prog = MathematicalProgram()

        # Initialize decision variables
        n_x = self.x_0.shape[0]  # size of state vector
        n_u = 1  # size of input vector TODO: potentiall change this

        x = np.zeros((self.N, n_x), dtype="object")
        u = np.zeros((self.N, n_u), dtype="object")

        for i in range(self.N):
            x[i] = prog.NewContinuousVariables(n_x, "x_" + str(i))
            u[i] = prog.NewContinuousVariables(n_u, "u_" + str(i))

        x_f = x[-1]

        # Intialize time parameters
        t_0 = 0.0  # initial time [s]
        t_land = prog.NewContinuousVariables(1, "t_land")  # [s]
        timesteps = np.linspace(t_0, t_f, self.N)  # [s]

        # Initial and final state constraints
        prog.AddLinearEqualityConstraint(x[0], self.x_0)  # constraint on initial state
        self.add_final_state_constraint(
            prog, x_f, jumping_distance, t_land
        )  # constraint on final state

        # Dynamics constraints
        self.add_dynamics_constraint(prog, x, u, timesteps)

        # Add foot constraint
        bounds = np.array([0, 0, 0])
        for i in range(self.N):
            prog.AddLinearEqualityConstraint(x[i, :3], bounds)

        # Add spring constraint
        for i in range(self.N - 1):
            d = np.sqrt(
                (x[i, 4] - x[i, 0]) ** 2
                + (x[i, 5] - x[i, 1]) ** 2
                + (x[i, 6] - x[i, 2]) ** 2
            )
            prog.AddConstraint(d - x[i, 3] <= self.aslip.L_0)
            prog.AddConstraint(d >= 0)

        # Find delta t
        dt = timesteps[1] - timesteps[0]  # [s]

        # Add cost
        cost = 0
        for i in range(self.N - 1):
            u_i = u[i]
            u_ip1 = u[i + 1]
            cost += (dt / 2.0) + (u_i.T @ u_i + u_ip1.T @ u_ip1)
        prog.AddQuadraticCost(cost)

        # Add initial guess
        for i in range(self.N):
            prog.SetInitialGuess(x[i, :], self.x_0)
            prog.SetInitialGuess(u[i, 0], np.array([0]))

        # Solve optimiation problem
        result = Solve(prog)
        x_sol = result.GetSolution(x)
        u_sol = result.GetSolution(u)
        t_land_sol = result.GetSolution(t_land)

        # Reconstruct trajectory
        x_dot_sol = np.zeros(x_sol.shape)
        for i in range(self.N):
            x_dot_sol[i] = self.aslip.f(x_sol[i], u_sol[i])
        # x_traj = PiecewisePolynomial.CubicHermite(timesteps, x_sol.T, x_dot_sol.T)
        x_traj = CubicHermiteSpline(timesteps, x_sol[:, 4], x_dot_sol[:, 4])
        z_traj = CubicHermiteSpline(timesteps, x_sol[:, 6], x_dot_sol[:, 6])

        # u_traj = PiecewisePolynomial.ZeroOrderHold(timesteps, u_sol.T)

        return x_traj, z_traj

    def add_final_state_constraint(
        self,
        prog: MathematicalProgram,
        x_f: np.array,
        jumping_distance: np.array,
        t_land: float,
    ):
        """
        Creates a constraint on the final state of the CoM

        Arguments:
            prog - (MathematicalProgram) optimization setup
            x_f - (np.array) final state right before leaving ground
            jumping distance - (np.array) distance in x & y the CoM should jump [m]
            t_land - (float) final time where CoM "lands" [s]
        """

        def landing_constraint(vars: np.array) -> np.array:
            """
            Internal function to setup landing constraint

            Arguments:
                vars - (np.array) array of constraint variables [x, t_land]

            Returns:
                constraint_eval - (np.array) array of variables to contrain
            """
            # Setup constraint
            constraint_eval = np.zeros((4,), dtype=AutoDiffXd)

            # Get state variables
            q = vars[:7]
            q_dot = vars[7:14]

            # Get landing time
            t_land = vars[-1]  # landing time [s]

            # Foot state variables
            p_foot = q[:3]  # Foot position [m]

            # CoM state variabkes
            p_com = q[4:7]  # CoM position [m]
            v_com = q_dot[4:7]  # CoM velocity [m/s]

            # "Initial" states for kinematics
            x_foot, y_foot, z_foot = p_foot[0], p_foot[1], p_foot[2]
            x_com_i, y_com_i, z_com_i = p_com[0], p_com[1], p_com[2]
            v_com_x_i, v_com_y_i, v_com_z_i = v_com[0], v_com[1], v_com[2]

            # "Final" states for kinematics
            x_com_f = x_com_i + v_com_x_i * t_land
            y_com_f = y_com_i + v_com_y_i * t_land
            z_com_f = (
                z_com_i + v_com_z_i * t_land + (1 / 2) * self.aslip.g * t_land**2
            )

            # Setup constraints
            constraint_eval[0] = x_com_f
            constraint_eval[1] = y_com_f
            constraint_eval[2] = z_com_f - q[3]
            constraint_eval[3] = (
                np.sqrt(
                    (x_com_i - x_foot) ** 2
                    + (y_com_i - y_foot) ** 2
                    + (z_com_i - z_foot) ** 2
                )
                - q[3]
            )

            # constraint_eval = [constraint_eval[i] for i in range(4)]

            return constraint_eval

        # Kinematic constraints
        x_jump = jumping_distance[0]  # TODO
        y_jump = jumping_distance[1]
        bounds = np.array(
            [x_jump, y_jump, self.aslip.L_0, self.aslip.L_0]
        )  # TODO z constraint
        prog.AddConstraint(landing_constraint, bounds, bounds, np.hstack((x_f, t_land)))

        # Constraint on landing time
        prog.AddConstraint(t_land[0] >= 0)

    def add_dynamics_constraint(
        self, prog: MathematicalProgram, x: np.array, u: np.array, timesteps: np.array
    ):
        """
        Adds aSLIP dynamics constraints

        Arguments:
            prog - (MathematicalProgram) optimization setup
            x - (np.array) state decision variables
            u - (np.array) input decision variables
            timesteps - (np.array) timesteps array [s]
        """

        def collocation_constraint_evaluator(
            dt: float, x_i: np.array, u_i: float, x_ip1: np.array, u_ip1: float
        ) -> np.array:
            """
            Establishes collocation constraint variables

            Arguments:
                x_i - (np.array) aSLIP state at ith timestep
                u_i - (np.array) input at ith timestep
                x_ip1 - (np.array) aSLIP state at (i+1)th timestep
                u_ip1 - (np.array) input at (i+1)th timestep

            Returns:
                h_i - (np.array) collocation constraints
            """
            n_x = self.x_0.shape[0]
            # h_i = np.zeros((n_x,))

            f_i = self.aslip.f(x_i, u_i[0])
            f_ip1 = self.aslip.f(x_ip1, u_ip1[0])

            s_dot_i = (1.5 / dt) * (x_ip1 - x_i) - 0.25 * (f_i + f_ip1)
            s_i = 0.5 * (x_i + x_ip1) - (dt / 8.0) * (f_ip1 - f_i)

            h_i = s_dot_i - self.aslip.f(s_i, 0.5 * (u_ip1[0] + u_i[0]))

            return h_i

        # Get state and input sizes
        n_x = self.x_0.shape[0]
        n_u = 1

        # Add dynamics (collocation) constraints
        for i in range(self.N - 1):

            def collocation_constraint_helper(vars) -> np.array:
                """
                Assists in collocation constraints

                Arguments:
                    vars - (np.array) array of constraint variables [x_i, u_i, x_ip1, u_ip1]

                Returns:
                    collocation_constraints - (np.array) collocation setup
                """
                x_i = vars[:n_x]
                u_i = vars[n_x : n_x + n_u]
                x_ip1 = vars[n_x + n_u : 2 * n_x + n_u]
                u_ip1 = vars[-n_u:]
                collocation_constraints = collocation_constraint_evaluator(
                    timesteps[i + 1] - timesteps[i], x_i, u_i, x_ip1, u_ip1
                )
                return collocation_constraints

            bounds = np.zeros((n_x,))
            bounds = np.zeros((n_x,))
            prog.AddConstraint(
                collocation_constraint_helper,
                bounds,
                bounds,
                np.hstack((x[i], u[i], x[i + 1], u[i + 1])),
            )


if __name__ == "__main__":
    planner = OfflinePlanner()
    x_traj, z_traj = planner.find_com_trajectory(
        planner.aslip.x_0 * 2, 2, np.array([2, 0])
    )

    # print(x_traj.shape)
    t = np.linspace(0, 2, 100)
    plt.figure()
    plt.plot(x_traj(t), z_traj(t))
    plt.show()

    plt.figure()
    plt.plot(t, z_traj(t))
    plt.show()
